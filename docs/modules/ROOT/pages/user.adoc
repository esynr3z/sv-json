:url-svjson-github: https://github.com/esynr3z/svjson/tree/{page-origin-refname}
:url-svjson-github-src: https://github.com/esynr3z/svjson/blob/{page-origin-refname}/src
// Common classes
:class-json-decoder: {url-svjson-github-src}/json_decoder.sv[json_decoder]
:class-json-encoder: {url-svjson-github-src}/json_encoder.sv[json_encoder]
:class-json-error: {url-svjson-github-src}/json_error.sv[json_error]
:class-json-result: {url-svjson-github-src}/json_result.sv[json_result]
// JSON value classes
:class-json-value: {url-svjson-github-src}/values/json_value.sv[json_value]
:class-json-array: {url-svjson-github-src}/values/json_array.sv[json_array]
:class-json-bits: {url-svjson-github-src}/values/json_bits.sv[json_bits]
:class-json-bool: {url-svjson-github-src}/values/json_bool.sv[json_bool]
:class-json-enum: {url-svjson-github-src}/values/json_enum.sv[json_enum]
:class-json-int: {url-svjson-github-src}/values/json_int.sv[json_int]
:class-json-object: {url-svjson-github-src}/values/json_object.sv[json_object]
:class-json-real: {url-svjson-github-src}/values/json_real.sv[json_real]
:class-json-string: {url-svjson-github-src}/values/json_string.sv[json_string]
// JSON encodable classes
:class-json-value-encodable: {url-svjson-github-src}/encodable/json_value_encodable.sv[json_value_encodable]
:class-json-bool-encodable: {url-svjson-github-src}/encodable/json_bool_encodable.sv[json_bool_encodable]
:class-json-enum-encodable: {url-svjson-github-src}/encodable/json_enum_encodable.sv[json_enum_encodable]
:class-json-int-encodable: {url-svjson-github-src}/encodable/json_int_encodable.sv[json_int_encodable]
:class-json-object-encodable: {url-svjson-github-src}/encodable/json_object_encodable.sv[json_object_encodable]
:class-json-real-encodable: {url-svjson-github-src}/encodable/json_real_encodable.sv[json_real_encodable]
:class-json-string-encodable: {url-svjson-github-src}/encodable/json_string_encodable.sv[json_string_encodable]

= User guide

== Integration

* Any simulator with extensive SystemVerilog OOP support required
* No external dependencies
* No defines
* No plusargs

IMPORTANT: The package is developed and tested using Verilator 5.24 only. Support of other simulators is planned, but Verilator still will be the main simulator for project as it is the only viable option to organize CI and opensource flow.

Sources and include directories are expressed as filelist (`.f` file), which is quite standard way of describing compilation unit for many EDA tools. Filelist of the project is {url-svjson-github-src}/filelist.f[`src/filelist.f`].

In order to make filelist portable, all paths are relative to `SVJSON_ROOT` environment variable. It should point to {url-svjson-github}[svjson] repository root in your filesystem.

As a result, integration process consists of several simple steps:

* Clone or copy {url-svjson-github}[svjson] repository
* Set environment variable `SVJSON_ROOT` with a path to the repository root on your filesystem
* Add filelist to your simulator compilation options, e.g. `-f ${SVJSON_ROOT}/src/filelist.f`
* `json_pkg` is ready to be compiled and used

== JSON Values

[[note-object-keys-order]]
NOTE: SystemVerilog associative array is used to implement JSON object. As a consequence, all keys are stored in a lexicographical order (IEEE IEEE-1800-2023, ch. 7.8.2) and original order of keys within source JSON is lost. This also affects encoder, so it always prints keys in a lexicographical order.

== JSON Decoder

JSON decoder designed as an abstract class `{class-json-decoder}` that allows to parse either JSON string or file using corresponding static method:

- `json_decoder::load_string(string str)`
- `json_decoder::load_file(string path)`

IMPORTANT: For the compatibility of EDA tools only pure ASCII character set has to be used. `\b` and `\u` escape sequences are not supported.

Parsing result is returned as `{class-json-result}` instance, that wraps either `{class-json-error}` or `{class-json-value}`.
To avoid error handling and get parsed value immediately method `unwrap()` can be used.
However, `$fatal()` is thrown, when try to unwrap underlying error. This is described in details in <<json-error-and-result,JSON Error and Result>> section below.

In case of successful parsing, after `json_value` is extracted out from the result, it can be inspected and casted to any known JSON value class. More details in <<json-values,JSON Values>> section.

IMPORTANT: Key order of any object being parsed is not preserved due to internal implementation, see <<note-object-keys-order,the note>>.

Decoder is recursive, therefore nesting depth is limited. The limit is 1024 by default and it is controllable via additional argument to any `load_*` method.

Below are several examples of JSON decoding.

.Parse JSON file without processing of possible errors
[source,systemverilog]
----
initial begin
  // TODO
end
----

.Parse JSON string with processing of possible errors
[source,systemverilog]
----
initial begin
  // TODO
end
----

== JSON Encoder

JSON encoder designed as an abstract class `{class-json-encoder}`. It allows to dump JSON encodable value into either string or file using corresponding static methods:

- `json_encoder::dump_string(json_value_encodable obj)`
- `json_encoder::dump_file(json_value_encodable obj, string path)`

NOTE: There is no recursion detection for encoder.

Class {url-svjson-github-src}/encodable/json_value_encodable.sv[`json_value_encodable`] is a base interface class, that defines a tree of related <<json-encodable-interfaces,encodable classes>>. Any other class can implement one of these classes to use `json_encoder` for dumping into JSON. Default <<json-values,JSON value classes>> implement them out of the box.

Dumping result is returned as `{class-json-result}` instance, that wraps either `string` or `{class-json-error}`.
To avoid error handling and get parsed value immediately method `unwrap()` can be used.
However, `$fatal()` is thrown, when try to unwrap underlying error. This is described in details in <<json-error-and-result,JSON Error and Result>> section below.

IMPORTANT: Keys of any object always follow lexicographical order while dumping due to internal implementation, see <<note-object-keys-order,the note>>.

Below are several examples of JSON encoding.

.Dump JSON file with processing of possible errors
[source,systemverilog]
----
initial begin
  // TODO
end
----

.Dump JSON string without processing of possible errors
[source,systemverilog]
----
initial begin
  // TODO
end
----

=== JSON Encodable Interfaces

TODO


== JSON Error and Result

TODO
