:url-svjson-github: https://github.com/esynr3z/svjson/tree/{page-origin-refname}
:url-svjson-github-src: https://github.com/esynr3z/svjson/blob/{page-origin-refname}/src
:url-ecma-404: https://ecma-international.org/publications-and-standards/standards/ecma-404
// Common classes
:class-json-decoder: {url-svjson-github-src}/json_decoder.sv[json_decoder]
:class-json-encoder: {url-svjson-github-src}/json_encoder.sv[json_encoder]
:class-json-error: {url-svjson-github-src}/json_error.sv[json_error]
:class-json-result: {url-svjson-github-src}/json_result.sv[json_result]
// JSON value classes
:class-json-value: {url-svjson-github-src}/values/json_value.sv[json_value]
:class-json-array: {url-svjson-github-src}/values/json_array.sv[json_array]
:class-json-bits: {url-svjson-github-src}/values/json_bits.sv[json_bits]
:class-json-bool: {url-svjson-github-src}/values/json_bool.sv[json_bool]
:class-json-enum: {url-svjson-github-src}/values/json_enum.sv[json_enum]
:class-json-int: {url-svjson-github-src}/values/json_int.sv[json_int]
:class-json-object: {url-svjson-github-src}/values/json_object.sv[json_object]
:class-json-real: {url-svjson-github-src}/values/json_real.sv[json_real]
:class-json-string: {url-svjson-github-src}/values/json_string.sv[json_string]
// JSON encodable classes
:class-json-value-encodable: {url-svjson-github-src}/encodable/json_value_encodable.sv[json_value_encodable]
:class-json-bool-encodable: {url-svjson-github-src}/encodable/json_bool_encodable.sv[json_bool_encodable]
:class-json-enum-encodable: {url-svjson-github-src}/encodable/json_enum_encodable.sv[json_enum_encodable]
:class-json-int-encodable: {url-svjson-github-src}/encodable/json_int_encodable.sv[json_int_encodable]
:class-json-object-encodable: {url-svjson-github-src}/encodable/json_object_encodable.sv[json_object_encodable]
:class-json-real-encodable: {url-svjson-github-src}/encodable/json_real_encodable.sv[json_real_encodable]
:class-json-string-encodable: {url-svjson-github-src}/encodable/json_string_encodable.sv[json_string_encodable]

= User guide

== Integration

* Any simulator with extensive SystemVerilog OOP support required
* No external dependencies
* No defines
* No plusargs

IMPORTANT: The package is developed and tested using Verilator 5.24 only. Support of other simulators is planned, but Verilator still will be the main simulator for project as it is the only viable option to organize CI and opensource flow.

Sources and include directories are expressed as filelist (`.f` file), which is quite standard way of describing compilation unit for many EDA tools. Filelist of the project is {url-svjson-github-src}/filelist.f[`src/filelist.f`].

In order to make filelist portable, all paths are relative to `SVJSON_ROOT` environment variable. It should point to {url-svjson-github}[svjson] repository root in your filesystem.

As a result, integration process consists of several simple steps:

* Clone or copy {url-svjson-github}[svjson] repository
* Set environment variable `SVJSON_ROOT` with a path to the repository root on your filesystem
* Add filelist to your simulator compilation options, e.g. `-f ${SVJSON_ROOT}/src/filelist.f`
* `json_pkg` is ready to be compiled and used

== JSON Values

According to the {url-ecma-404}[JSON specification] there are 6 JSON value types.

The implementation follows the specification - these types are represented as a special wrapper classes of underlying SV types. However, there are some nuances. Summary table is below.

.JSON values summary
[cols="1,1,1,3"]
|===
| JSON value | Class | Underlying SV type | Note

| - | `{class-json-value}` | - | Generic JSON value. Base class for all other values.

| Object | `{class-json-object}` | Associative array | Class representation of JSON object.

| Array | `{class-json-array}` | Queue | Class representation of JSON array.

.2+| Number
| `{class-json-int}` | `longint` | Class representation of JSON integer number.
| `{class-json-real}` | `real` | Class representation of JSON real number.

| Bool | `{class-json-bool}` | `bit` | Class representation of JSON bool.

.3+| String

| `{class-json-string}` | `string` | Class representation of JSON string.
| `{class-json-enum}` | Parameterized enum | Class is inherited from JSON string. Can be used to convert custom enum type to and from string during JSON manipulations.
| `{class-json-bits}` | Parameterized bit vector | Class is inherited from JSON string. Can be used to convert bit vector of custom width to and from string during JSON manipulations. This allows to use numbers of any width represented as strings in JSON.

| Null | - | `null` | There is no special class to represent JSON null. Native `null` is used for this.
|===

Inheritance tree for JSON values is shown below.

[plantuml,svg]
....
abstract json_value

json_value <|-- json_object
json_value <|-- json_array
json_value <|-- json_string

class json_enum<ENUM_T>
json_string <|-- json_enum

class json_bits<BITS_T>
json_string <|-- json_bits

json_value <|-- json_int
json_value <|-- json_real
json_value <|-- json_bool
....

=== Base Value

Class `{class-json-value}` is a base abstract class for all JSON values. This class is mainly used for polymorphism goals - to represent any value while decoding/encoding JSON. It has no parameters or attributes and almost all of its methods are for introspection and convenient casting to one of concrete classes.

.json_value methods outline
[cols="1,1"]
|===
| `bit compare(json_value value)` | Perform compare with another instance. Return 1 if instances are equal and 0 otherwise.
| `json_value clone()` | Create a deep copy of an instance.
| `bit is_json_<val>` (e.g. `is_json_object`, `is_json_array`, etc.) | Check if current instance is specified type.
| `json_result#(json_<val>) as_json_<val>()` (e.g. `as_json_object`, `as_json_array`, etc.) | Try to cast to specified concrete class.
| `bit matches_json_<val>(output json_<val> value)` (e.g. `matches_json_object`, `matches_json_array`, etc.) | Another option of trying to cast to specified concrete class. In this case, instance is an `output` argument, and returned result is 1 for success, 0 otherwise.
|===

=== Object

`{class-json-object}` wrapper class represens standard JSON object value using SV `string`-indexed associative array of `{class-json-value}`. The class basically wraps standard SV associative array methods with some additional methods required to operate as JSON value.

No additional checks are implemented for "out-of-range" accesses and similar, so you can expect that this class will operate according to behavior of an original underlying SV associative array.

[[note-object-keys-order]]
NOTE: SystemVerilog associative array is used to implement JSON object. As a consequence, all keys are stored in a lexicographical order (IEEE IEEE-1800-2023, ch. 7.8.2) and original order of keys within source JSON is lost. This also affects encoder, so it always prints keys in a lexicographical order.

.json_object methods outline
[cols="1,1"]
|===
| `new(values_t values)` | Create an instance from an associative array.
| `json_object from(values_t values)` | Static method to create an instance from an associative array. Alternative to standard constructor.
| `json_value get(string key)` | Get a value at the provided key.
| `void set(string key, json_value value)` | Set the given value for the provided key.
| `values_t get_values()` | Get all internal values as associative array.
| `keys_t get_keys()` | Get all keys for internal values as queue.
| `void flush()` | Remove all stored values.
| `size()`, `exists()`, `delete()`, `first()`, `last()`, `next()`, `prev()` | Thin wrappers over the standard associative array methods which also mimic their signature and return values.
|===

=== Array

`{class-json-array}` wrapper class represens standard JSON array value using SV queue of `{class-json-value}`.
The class basically wraps standard SV queue methods with some additional methods required to operate as JSON value.

No additional checks are implemented for "out-of-range" accesses and similar,
so you can expect that this class will operate according to behavior of an original underlying SV queue.

.json_array methods outline
[cols="1,1"]
|===
| `new(values_t values)` | Create an instance from a queue.
| `json_array from(values_t values)` | Static method to create an instance from a queue. Alternative to standard constructor.
| `json_value get(int index)` | Get a value at the provided index.
| `void set(int index, json_value value)` | Set the given value for the provided index.
| `values_t get_values()` | Get all internal values as queue.
| `void flush()` | Remove all stored values.
| `size()`, `insert()`, `delete()`, `push_front()`, `push_back()`, `pop_front()`, `pop_back()` | Thin wrappers over the standard queue methods which also mimic their signature and return values.
|===

=== String

`{class-json-string}` wrapper class represens standard JSON string value type using SV string.

IMPORTANT: `\b` and `\u` escape sequences are not supported.

.json_string methods outline
[cols="1,1"]
|===
| `new(string value)` | Create an instance from a string.
| `json_string from(string value)` | Static method to create an instance from a string. Alternative to standard constructor.
| `string get()` | Get internal string value.
| `void set(string value)` | Set internal string value.
|===

==== Extension: Enum

`{class-json-enum}#(ENUM_T)` wrapper class, that inherits from `{class-json-string}` and represens SV `enum` value as standard JSON string.
The class is parametrized with type `ENUM_T` to work with any enumeration.

Purpose of this class is to facilitate using SV enum with JSON decoder/encoder. For example, JSON values tree can be created with `{class-json-enum}` instances and then they can be seamlessly converted to strings during encoding. And vice versa for decoding.

.json_enum#(ENUM_T) methods outline
[cols="1,1"]
|===
| `new(ENUM_T value)` | Create an instance from an `enum`.
| `json_enum#(ENUM_T) from(ENUM_T value)` | Static method to create an instance from an `enum`. Alternative to standard constructor.
| json_result#(json_enum#(ENUM_T)) from_string(string value) | Static method to create an instance from a `string`. Alternative to standard constructor. This option is failable, because only specific string (enumeration variants) can be used to create valid `json_enum`.
| `string get()` | Get internal enum value as a string.
| `void set(string value)` | Set internal enum value from a string. This function may fail due to wrong value is provided, and this fail is unrecoverable (fatal).
| `ENUM_T get_enum()` | Get internal enum value.
| `void set_enum(ENUM_T value)` | Set internal enum value.
|===

==== Extension: Bit Vector

`{class-json-bits}#(BITS_T)` wrapper class, that inherits from `{class-json-string}` and represens SV bit vector value (e.g. `bit[511:0]`) as standard JSON string.
The class is parametrized with type `BITS_T` to work with any bit vector - any width, signed or unsigned. Packed structures can be used as well.

Purpose of this class is to facilitate using SV bit vectors of arbitrary size with JSON decoder/encoder.
As a result, any number, that cannot be represented as JSON number using `longint` or `real`, can be represented as a string.

There is an internal property `preferred_radix`, that can take values: `json_bits::RADIX_DEC`, `json_bits::RADIX_BIN` or `json_bits::RADIX_HEX`. This property can be changed any time and affects how bit vector is converted to the string - what base is used.

.json_bits#(BITS_T) methods outline
[cols="1,1"]
|===
| `new(BITS_T value, radix_e preferred_radix=RADIX_DEC)` | Create an instance from a bit vector.
| `json_bits#(BITS_T) from(BITS_T value, radix_e preferred_radix=RADIX_DEC)` | Static method to create an instance from a bit vector. Alternative to standard constructor.
| `json_result#(json_bits#(BITS_T)) from_string(string value)` | Static method to create an instance from a `string`. Alternative to standard constructor. This option is failable, because only specific string can be used to create valid `json_bits`. It should contain only numbers "0"-"9", letters "a"-"f". Prefix "0x" is allowed for hexadecimal values and "0b" for binary ones. Radix is discovered automatically and saved into `preferred_radix`.
| `string get()` | Get internal bit vector value as a string.
| `void set(string value)` | Set internal bit vector value from a string. This function may fail due to wrong value is provided, and this fail is unrecoverable (fatal).
| `BITS_T get_bits()` | Get internal bit vector value.
| `set_bits(BITS_T value)` | Set internal bit vector value.
|===

=== Number

JSON standard does not specify requirements for number types, but usually it is more convenient to operate with integers and real numbers separately. Hence, several classes are used to represent JSON number.

==== Integer Number

`{class-json-int}` wrapper class represens JSON integer number value using SV `longint`.

.json_int methods outline
[cols="1,1"]
|===
| `new(longint value)` | Create an instance from a `longint`.
| `json_int from(longint value)` | Static method to create an instance from a `longint`. Alternative to standard constructor.
| `longint get()` | Get internal `longint` value.
| `void set(longint value)` | Set internal `longint` value.
|===

==== Real Number

`{class-json-real}` wrapper class represens JSON real number value using SV `real`.

.json_real methods outline
[cols="1,1"]
|===
| `new(real value)` | Create an instance from a `real`.
| `json_real from(real value)` | Static method to create an instance from a `real`. Alternative to standard constructor.
| `real get()` | Get internal `real` value.
| `void set(real value)` | Set internal `real` value.
|===

=== Bool

`{class-json-bool}` wrapper class represens standard JSON bool value type using SV `bit`.

.json_bool methods outline
[cols="1,1"]
|===
| `new(bit value)` | Create an instance from a `bit`.
| `json_bit from(bit value)` | Static method to create an instance from a `bit`. Alternative to standard constructor.
| `bit get()` | Get internal `bit` value.
| `void set(bit value)` | Set internal `bit` value.
|===

== JSON Decoder

JSON decoder designed as an abstract class `{class-json-decoder}` that allows to parse either JSON string or file using corresponding static method:

- `json_decoder::load_string(string str)`
- `json_decoder::load_file(string path)`

IMPORTANT: For the compatibility of EDA tools only pure ASCII character set has to be used. `\b` and `\u` escape sequences are not supported.

Parsing result is returned as `{class-json-result}` instance, that wraps either `{class-json-error}` or `{class-json-value}`.
To avoid error handling and get parsed value immediately method `unwrap()` can be used.
However, `$fatal()` is thrown, when try to unwrap underlying error. This is described in details in <<json-error-and-result,JSON Error and Result>> section below.

In case of successful parsing, after `json_value` is extracted out from the result, it can be inspected and casted to any known JSON value class. More details in <<json-values,JSON Values>> section.

IMPORTANT: Key order of any object being parsed is not preserved due to internal implementation, see <<note-object-keys-order,the note>>.

Decoder is recursive, therefore nesting depth is limited. The limit is 1024 by default and it is controllable via additional argument to any `load_*` method.

Below are several examples of JSON decoding.

.Parse JSON file without processing of possible errors
[source,systemverilog]
----
initial begin
  // TODO
end
----

.Parse JSON string with processing of possible errors
[source,systemverilog]
----
initial begin
  // TODO
end
----

== JSON Encoder

JSON encoder designed as an abstract class `{class-json-encoder}`. It allows to dump JSON encodable value into either string or file using corresponding static methods:

- `json_encoder::dump_string(json_value_encodable obj)`
- `json_encoder::dump_file(json_value_encodable obj, string path)`

NOTE: There is no recursion detection for encoder.

Class {url-svjson-github-src}/encodable/json_value_encodable.sv[`json_value_encodable`] is a base interface class, that defines a tree of related <<json-encodable-interfaces,encodable classes>>. Any other class can implement one of these classes to use `json_encoder` for dumping into JSON. Default <<json-values,JSON value classes>> implement them out of the box.

Dumping result is returned as `{class-json-result}` instance, that wraps either `string` or `{class-json-error}`.
To avoid error handling and get parsed value immediately method `unwrap()` can be used.
However, `$fatal()` is thrown, when try to unwrap underlying error. This is described in details in <<json-error-and-result,JSON Error and Result>> section below.

IMPORTANT: Keys of any object always follow lexicographical order while dumping due to internal implementation, see <<note-object-keys-order,the note>>.

Below are several examples of JSON encoding.

.Dump JSON file with processing of possible errors
[source,systemverilog]
----
initial begin
  // TODO
end
----

.Dump JSON string without processing of possible errors
[source,systemverilog]
----
initial begin
  // TODO
end
----

=== JSON Encodable Interfaces

TODO


== JSON Error and Result

TODO
