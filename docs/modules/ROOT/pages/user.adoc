:url-svjson-github: https://github.com/esynr3z/svjson/tree/{page-origin-refname}
:url-svjson-github-src: https://github.com/esynr3z/svjson/blob/{page-origin-refname}/src
:url-ecma-404: https://ecma-international.org/publications-and-standards/standards/ecma-404
// Common classes
:class-json-decoder: {url-svjson-github-src}/json_decoder.sv[json_decoder]
:class-json-encoder: {url-svjson-github-src}/json_encoder.sv[json_encoder]
:class-json-error: {url-svjson-github-src}/json_error.sv[json_error]
:class-json-result: {url-svjson-github-src}/json_result.sv[json_result]
// JSON value classes
:class-json-value: {url-svjson-github-src}/values/json_value.sv[json_value]
:class-json-array: {url-svjson-github-src}/values/json_array.sv[json_array]
:class-json-bits: {url-svjson-github-src}/values/json_bits.sv[json_bits]
:class-json-bool: {url-svjson-github-src}/values/json_bool.sv[json_bool]
:class-json-enum: {url-svjson-github-src}/values/json_enum.sv[json_enum]
:class-json-int: {url-svjson-github-src}/values/json_int.sv[json_int]
:class-json-object: {url-svjson-github-src}/values/json_object.sv[json_object]
:class-json-real: {url-svjson-github-src}/values/json_real.sv[json_real]
:class-json-string: {url-svjson-github-src}/values/json_string.sv[json_string]
// JSON encodable classes
:class-json-value-encodable: {url-svjson-github-src}/encodable/json_value_encodable.sv[json_value_encodable]
:class-json-bool-encodable: {url-svjson-github-src}/encodable/json_bool_encodable.sv[json_bool_encodable]
:class-json-enum-encodable: {url-svjson-github-src}/encodable/json_enum_encodable.sv[json_enum_encodable]
:class-json-int-encodable: {url-svjson-github-src}/encodable/json_int_encodable.sv[json_int_encodable]
:class-json-object-encodable: {url-svjson-github-src}/encodable/json_object_encodable.sv[json_object_encodable]
:class-json-real-encodable: {url-svjson-github-src}/encodable/json_real_encodable.sv[json_real_encodable]
:class-json-string-encodable: {url-svjson-github-src}/encodable/json_string_encodable.sv[json_string_encodable]

= User guide

== Integration

* Any simulator with extensive SystemVerilog OOP support required
* No external dependencies
* No defines
* No plusargs

IMPORTANT: The package is developed and tested using Verilator 5.24 only. Support of other simulators is planned, but Verilator still will be the main simulator for project as it is the only viable option to organize CI and opensource flow.

Sources and include directories are expressed as filelist (`.f` file), which is quite standard way of describing compilation unit for many EDA tools. Filelist of the project is {url-svjson-github-src}/filelist.f[`src/filelist.f`].

In order to make filelist portable, all paths are relative to `SVJSON_ROOT` environment variable. It should point to {url-svjson-github}[svjson] repository root in your filesystem.

As a result, integration process consists of several simple steps:

* Clone or copy {url-svjson-github}[svjson] repository
* Set environment variable `SVJSON_ROOT` with a path to the repository root on your filesystem
* Add filelist to your simulator compilation options, e.g. `-f ${SVJSON_ROOT}/src/filelist.f`
* `json_pkg` is ready to be compiled and used

== JSON Values

{url-ecma-404}[JSON specification] states that there are 6 JSON value types.

The implementation follows the specification - these types are represented as a special wrapper classes of underlying SV types. However, there are some nuances. Summary table is below.

.JSON values summary
[cols="1,1,1,3"]
|===
| JSON value | Class | Underlying SV type | Note

| - | `{class-json-value}` | - | Generic JSON value. Base class for all other values.

| Object | `{class-json-object}` | Associative array | Class representation of JSON object.

| Array | `{class-json-array}` | Queue | Class representation of JSON array.

.2+| Number
| `{class-json-int}` | `longint` | Class representation of JSON integer number.
| `{class-json-real}` | `real` | Class representation of JSON real number.

| Bool | `{class-json-bool}` | `bit` | Class representation of JSON bool.

.3+| String

| `{class-json-string}` | `string` | Class representation of JSON string.
| `{class-json-enum}` | Parameterized enum | Class is inherited from JSON string. Can be used to convert custom enum type to and from string during JSON manipulations.
| `{class-json-bits}` | Parameterized bit vector | Class is inherited from JSON string. Can be used to convert bit vector of custom width to and from string during JSON manipulations. This allows to use numbers of any width represented as strings in JSON.

| Null | - | `null` | There is no special class to represent JSON null. Native `null` is used for this.
|===

Inheritance tree for JSON values is shown below.

[plantuml,svg]
....
abstract json_value

json_value <|-- json_object
json_value <|-- json_array
json_value <|-- json_string

class json_enum<ENUM_T>
json_string <|-- json_enum

class json_bits<BITS_T>
json_string <|-- json_bits

json_value <|-- json_int
json_value <|-- json_real
json_value <|-- json_bool
....


=== Base JSON Value

=== JSON Object

[[note-object-keys-order]]
NOTE: SystemVerilog associative array is used to implement JSON object. As a consequence, all keys are stored in a lexicographical order (IEEE IEEE-1800-2023, ch. 7.8.2) and original order of keys within source JSON is lost. This also affects encoder, so it always prints keys in a lexicographical order.

=== JSON Array

=== JSON String

==== Extension: enum

==== Extension: bit vector

=== JSON Number

==== Integer

==== Real

=== JSON Bool

== JSON Decoder

JSON decoder designed as an abstract class `{class-json-decoder}` that allows to parse either JSON string or file using corresponding static method:

- `json_decoder::load_string(string str)`
- `json_decoder::load_file(string path)`

IMPORTANT: For the compatibility of EDA tools only pure ASCII character set has to be used. `\b` and `\u` escape sequences are not supported.

Parsing result is returned as `{class-json-result}` instance, that wraps either `{class-json-error}` or `{class-json-value}`.
To avoid error handling and get parsed value immediately method `unwrap()` can be used.
However, `$fatal()` is thrown, when try to unwrap underlying error. This is described in details in <<json-error-and-result,JSON Error and Result>> section below.

In case of successful parsing, after `json_value` is extracted out from the result, it can be inspected and casted to any known JSON value class. More details in <<json-values,JSON Values>> section.

IMPORTANT: Key order of any object being parsed is not preserved due to internal implementation, see <<note-object-keys-order,the note>>.

Decoder is recursive, therefore nesting depth is limited. The limit is 1024 by default and it is controllable via additional argument to any `load_*` method.

Below are several examples of JSON decoding.

.Parse JSON file without processing of possible errors
[source,systemverilog]
----
initial begin
  // TODO
end
----

.Parse JSON string with processing of possible errors
[source,systemverilog]
----
initial begin
  // TODO
end
----

== JSON Encoder

JSON encoder designed as an abstract class `{class-json-encoder}`. It allows to dump JSON encodable value into either string or file using corresponding static methods:

- `json_encoder::dump_string(json_value_encodable obj)`
- `json_encoder::dump_file(json_value_encodable obj, string path)`

NOTE: There is no recursion detection for encoder.

Class {url-svjson-github-src}/encodable/json_value_encodable.sv[`json_value_encodable`] is a base interface class, that defines a tree of related <<json-encodable-interfaces,encodable classes>>. Any other class can implement one of these classes to use `json_encoder` for dumping into JSON. Default <<json-values,JSON value classes>> implement them out of the box.

Dumping result is returned as `{class-json-result}` instance, that wraps either `string` or `{class-json-error}`.
To avoid error handling and get parsed value immediately method `unwrap()` can be used.
However, `$fatal()` is thrown, when try to unwrap underlying error. This is described in details in <<json-error-and-result,JSON Error and Result>> section below.

IMPORTANT: Keys of any object always follow lexicographical order while dumping due to internal implementation, see <<note-object-keys-order,the note>>.

Below are several examples of JSON encoding.

.Dump JSON file with processing of possible errors
[source,systemverilog]
----
initial begin
  // TODO
end
----

.Dump JSON string without processing of possible errors
[source,systemverilog]
----
initial begin
  // TODO
end
----

=== JSON Encodable Interfaces

TODO


== JSON Error and Result

TODO
